************************ PIPEX *************************

the first function : ft_pipex  take argv and env as argument
		- create a pipe;
		- fork() and pass a function to the child process ;
		- close the second file descriptor of the pipe ;
		- fork() again and pass a function to the second process;
		- wait for both of them;

the first process : ft_child take as argument : **av **env *pipe_fd
		- close(0) if i open now a file it will take 0 as file decriptor;
		- open(infile) ; for read only and  check if open success;
		- close (pipe_fd[0]);
		- dup2(pfd[1], stdout) and check if an error occured ; this function it make now the pfd[1] as stdout;
		- i should close (pfd[1]);
	
		- invoke : ft_exec(av, env, 2)
					{
						- declare a variable (char **v_av);
						- declare a variable (char *_cmd);

						- v_av = take the first command and split it by ' ' space separator;
							protect null;
						- if (v_av[0] == NULL) that means he enter a empty command or a command like that "    ";
						
						- if (v_av[0][0] == '/') that means he enter the path of the command then i should execute 
							this command if it can , if it can't execute then print error ;

						now initialise v_cmd = ft_get_cmd(env, v_av[0], v_av); v_av[0] = the name of the program;

						call execve(v_cmd, v_av, env);
						if success it will not execut below instructions;

						perror("error) and free the memory
					}

					ft_get_cmd(**env, *cmd, **v_av)
					{
						declare 3 variable (char *answer) (char *v_arr) (int i);

						find if the PATH exixts in env variables :
							if it exist then  
								v_arr =  the PATH splitit to strings using ':' separator;
							if not then 
								print ERROR .... not found;

						invoke it ft_join_cmd(v_arr, cmd)
								{
									cmd = ft_strjoin("/", cmd); why i didn't put in tmp first and free it after join
																	because when i free v_arr it will be then error (double free)
									now join the { cmd } whith each string in {v_arr} 
									if an error occured free anything i allocate and return NULL 
									else if evrything OK return the pointer v_arr;
								}
						if (ft_join_cmd == NULL)
							free(v_arr which have the path string) ; free (v_av which the command and its argument) and exit;
						
						answer = ft_get_access_cmd(v_arr);
								check if can execute the path it return a copy to the path that i can execute
								else it return NULL;
						if (answer) == NULL 
							free(v_arr, v_av) print error ;
						else 
							free(v_arr) the return the answer;
					}
			- if it is here it means execve failed then exit (failure);

the second process : ft_parent (i should change this function name)
		same instruction just small change in the open file (create ...) and istead of reading from stdin he read 
			from the pipe and writeto file.
